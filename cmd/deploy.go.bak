/*
Copyright Â© 2020 NAME HERE <EMAIL ADDRESS>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"fmt"
	"os"

	"github.com/netapp/capv-bootstrap/pkg/config/types"
	"github.com/spf13/cobra"
)

// deployCmd represents the deploy command
var deployCmd = &cobra.Command{
	Use:   "deploy",
	Short: "A brief description of your command",
	Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	Run: func(cmd *cobra.Command, args []string) {
		spec := &types.ConfigSpec{}
		deployManagementCluster(spec)
	},
}

func init() {
	rootCmd.AddCommand(deployCmd)
	deployCmd.Flags().StringVarP(&(cliSettings.config), "config", "c", "", "The config.yaml file to use for deployment (bypass prompts)")
}

func deployManagementCluster(spec *types.ConfigSpec) {
	if cliSettings.config == "" {
		fmt.Println("need to generate a config here")
		runEasyConfig()
	}

	if cliSettings.config == "" {
		fmt.Println("no config file provided and genconfig seems to have failed")
		os.Exit(1)
	}

	collectNetworkInformation(spec)
	collectAdditionalConfiguration(spec)
	/*
		configureProviderSpecific(spec)
		if runningFromConfig {
			if err := registration.ValidateSpec(spec); err != nil {
				log.Fatalln(err)
			}
		}
	*/
}

//func register(spec *types.ConfigSpec) {
func deployServiceCluster(spec *types.ConfigSpec) {
	messages, logs := registration.Register(spec)
	var wg sync.WaitGroup

	folderName := spec.RegionName
	if err := createFolder(folderName); err != nil {
		log.Fatal(err.Error())
	}

	bootlogFile := registrationFile{
		Name:        "bootstrap-vm.log",
		Description: "Bootstrap VM output - Output from a vm in vCenter that helps provision the NKS service cluster",
	}

	privateKeyFile := registrationFile{
		Name:        "nks_private_key",
		Description: "Private SSH key - Can be used to access the infrastructure machines (bootstrap, load balancers, service cluster) for debugging purposes",
	}

	configFile := registrationFile{
		Name:        "config.yaml",
		Description: "Service Cluster Config.yaml - This file contains the config that was used during registration, this config can be used for re-registrations",
	}

	kubeconfigFile := registrationFile{
		Name:        "kubeconfig",
		Description: "Service Cluster kubeconfig - This file contains the kubeconfig that was created during registration, used this to access the service cluster",
	}

	describeFileStructure(folderName, bootlogFile, privateKeyFile, configFile, kubeconfigFile)

	wg.Add(1)
	go processLogs(logs, folderName, &wg)

	fmt.Printf("%-130s %s\n", "Message", "Progress")
	fmt.Printf("%-130s %s\n", "-------", "--------")
	basePath := nksBaseFolderPath()
	errorMessage := "Failed to register region. Reason: "
	extendedFailureMessage := fmt.Sprintf("\nDebug Logs stored are available in %s/%s", nksBaseFolderPath(), folderName)
	privateSSHKeyFileCreated := false
	for status := range messages {
		if status.Failed {
			if status.WaitForLogs {
				wg.Wait()
			}

			if status.Progress < 50 {
				log.Fatalf("\n%s %s.", errorMessage, status.Error)
			}

			log.Fatalf("\n%s %s.\n%s", errorMessage, status.Error, extendedFailureMessage)
		}

		fmt.Printf("%-130s %d\n", status.Message, status.Progress)
		const bootstrapLogFileMode = 0666
		if err := writeFile(fmt.Sprintf("%s/%s/%s", basePath, folderName, bootlogFile.Name), []byte(status.BootVMLog), bootstrapLogFileMode); err != nil {
			log.Fatal(err.Error())
		}

		if !privateSSHKeyFileCreated {
			const privateKeyFileMode = 400
			if err := writeFile(fmt.Sprintf("%s/%s/%s", basePath, folderName, privateKeyFile.Name), []byte(status.BootstrapPrivateSSHKey), privateKeyFileMode); err != nil {
				log.Fatal(err.Error())
			}
			privateSSHKeyFileCreated = true
		}

		const kubeconfigFileMode = 0666
		err := writeFile(fmt.Sprintf("%s/%s/%s", basePath, folderName, kubeconfigFile.Name), []byte(status.B64Kubeconfig), kubeconfigFileMode)
		if err != nil {
			log.Fatal(err.Error())
		}

		// When collecting logs on success we have to be careful
		// and wait for the goroutine to finish before the main exits
		if status.WaitForLogs {
			wg.Wait()
		}
	}

	fmt.Printf("Region %s successfully registered using provider %s in NetApp Kubernetes Services.\n", spec.RegionName, spec.Provider)
}
